# 按照位置划分

## 类修饰符

* public

* 默认修饰符friendly  （不写）

* abstract 抽象类

* final 不能被继承

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1gfm7ng6i5bj312s0jqaga.jpg)

## 成员变量修饰符

* public 

* protected  子类 以及同包能访问    意味着 子类只能使用this去访问

* 默认    同包能访问

* private

* final  只能赋值一次

  final 修饰成员变量必须要显示复制 否则会报错

  * 静态成员变量（类变量）有2个赋值时机
    1. 声明时赋值
    2. 静态代码块赋值
  * 实例变量有3个赋值时机
    1. 声明时赋值
    2. 普通代码块赋值
    3. 构造函数赋值

  **当final修饰基本数据类型变量时，不能对基本数据类型变量重新赋值，因此基本数据类型变量不能被改变。而对于引用类型变量而言，它仅仅保存的是一个引用，final只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的**。

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1gfm7kk9byhj30qu070abh.jpg)

* volatile 可见性

## 构造函数修饰符

* public （最常用，其他类的任何位置都可以访问）         

* protected（能够在同一包中被子类访问）

* 什么都不写，""(能够被同一包里的类访问)

*  private（经常使用的单例模式中）不能在别的类进行实例化

## 方法修饰符

* final

  ![](https://tva1.sinaimg.cn/large/007S8ZIlly1gfm7lz2t5wj31660hqgnx.jpg)

* static
* synchronize
* native，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。

# 按照功能划分











# 参考资料



> 　　protected是最难理解的一种Java类成员访问权限修饰词。在编程中，碰到涉及protected的调用时，首先要确定出该protected成员来自何方，其可见性范围是什么，然后就正确无误的使用了。
>
> https://blog.csdn.net/justloveyou_/article/details/61672133



> [final关键字全面解析](https://www.jianshu.com/p/1f4b0f98cbf1)