# Redis

基于内存的高性能数据库  广泛应用于缓存 分布式锁

## Redis 为什么这么快

1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4、使用多路I/O复用模型，非阻塞IO；

5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

## 为什么要用缓存\为什么要用Redis

* 高性能
  假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
* 高并发
  直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

## 为什么用Redis 而不是map\guava做缓存

因为Redis是分布式的

## Redis 和Memmcached的区别

* Redis支持更丰富的数据类型
* Redis支持数据持久化  快照 or AOF  记录命令
* Redis有原生的集群模式
* Memcached是多线程非阻塞IO Redis是单线程非阻塞IO

* String Hash（存储对象） List Set Incr `HSET key field value`

* Redis 过期时间   定期删除 和惰性删除



## Redis 内存淘汰机制 

  （MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据）
  redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）
  redis 提供 6种数据淘汰策略：
      volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
      volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
      volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
      allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）.
      allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
      no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！



## 缓存穿透

### 什么是缓存穿透

正常情况下，我们去查询数据都是存在。

那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。

**这种查询不存在数据的现象我们称为缓存穿透。**



### 穿透带来的问题

试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉

### 解决办法

#### 1. 缓存空值

之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。

那么我们就可以为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null 。

这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间

#### 2. 布隆过滤器 BloomFilter

BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中。

这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。

这种方案可以加在第一种方案中，在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -> 查 DB。

<img src="assets/image-20200610223156187.png" alt="image-20200610223156187" style="zoom:50%;" />

### 如何选择

针对于一些恶意攻击，攻击带过来的大量key 是不存在的，那么我们采用第一种方案就会缓存大量不存在key的数据。

此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些key。

针对这种key异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。

而对于空数据的key有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。



## 缓存击穿

### 什么是击穿

在平常高并发的系统中，**大量的请求同时查询一个 key 时，此时这个key正好失效了**，就会导致大量的请求都打到数据库上面去。这种现象我们称为**缓存击穿**。

### 会带来什么问题

会造成某一时刻数据库请求量过大，压力剧增。

### 如何解决

上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。

其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。

## 缓存雪崩

### 什么是缓存雪崩

缓存雪崩的情况是说，当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉。

缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是:**缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。**

### 解决办法

* 事前 使用集群缓存，保证缓存服务的高可用

  这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。

* 事中：ehcache本地缓存 + Hystrix**限流**&降级,避免MySQL被打死

  使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。

  使用 Hystrix进行限流 & 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。

  然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。

* 事后：开启Redis持久化机制，尽快恢复缓存集群



## 解决热点数据集中失效问题

我们在设置缓存的时候，一般会给缓存设置一个失效时间，过了这个时间，缓存就失效了。

对于一些热点的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况。

类似与缓存击穿

**解决办法**

* 设置不同的失效时间

  为了避免这些热点的数据集中失效，那么我们在设置缓存过期时间的时候，我们让他们失效的时间错开。

  比如在一个基础的时间上加上或者减去一个范围内的随机值。

* 互斥锁

  结合上面的击穿的情况，在第一个请求去查询数据库的时候对他加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，从而保护数据库。

  但是也是由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做。

## JAVA Redis client

 Jedis  lettuce  Redisson

## Redis持久化

### 1.Redis持久化是什么？

因为Redis是一个内存数据库，数据保存在内存中，一旦发生关机或者重启，内存中的数据都会丢失，所以为了能够重启时恢复数据，Redis提供了持久化的机制，正常运行期间根据策略生成持久化文件。在机器重启后，可以根据根据持久化文件恢复内存中的数据。Redis还为我们提供了持久化的机制。（虽然有主从同步，主机挂掉之后，可以让从节点成为主节点，但是如果整个机房都发生停电，那么主节点和从节点内存中的数据都会丢失，所以这也是持久化存在的意义。）

### 2.Redis持久化有哪些策略？

![image-20200610214025419](assets/image-20200610214025419.png)





* AOF 持久化

  记录写命令 类似于Mysql 的binlog, 

  AOF持久化主要是Redis在修改相关的命令后，将命令添加到aof_buf缓存区的末尾，然后在每次事件循环结束时，

  有几种同步方法 

  1. `appendfsync = always ` 执行一个写命令同步一次  最多只会丢失当前正在写入的命令
  2. `appendfsync = everysec` 每秒写一次 最多流失1秒数据 **常用**
  3. `appendfsync = no ` 由操作系统来觉得 一般是30S

* RDB 持久化

  快照



### 3.Redis的数据恢复策略是怎么样的？

1.如果配置了混合持久化，那么根据混合持久化文件进行恢复数据。（Redis4.0+）

2.只配置 AOF ，重启时加载 AOF 文件恢复数据。

3.同时配置了 RDB 和 AOF ，启动时只加载 AOF文件恢复数据，如果AOF文件损坏，那么根据RDB文件恢复数据。

4.只配置 RDB，启动时加载RDB持久化文件恢复数据。

### 4.Redis持久化策略该如何进行选择？

（因为混合持久化是Redis 4.0之后支持的，目前一般生成环境使用的Redis版本可能都还较低，所以这里的策略选择主要是针对AOF持久和RDB持久化进行技术选型。）

以下是几种持久化方案选择的场景：

#### 1.不需要考虑数据丢失的情况

那么不需要考虑持久化。

#### 2.单机实例情况下

可以接受丢失十几分钟及更长时间的数据，可以选择RDB持久化，对性能影响小，如果只能接受秒级的数据丢失，只能选择AOF持久化。

#### 3.在主从环境下

因为主服务器在执行修改命令后，会将命令发送给从服务器，从服务进行执行后，与主服务器保持数据同步，实现数据热备份，在master宕掉后继续提供服务。同时也可以进行读写分离，分担Redis的读请求。

##### 那么在从服务器进行数据热备份的情况下，是否还需要持久化呢？

需要持久化，因为不进行持久化，主服务器，从服务器同时出现故障时，会导致数据丢失。（例如：机房全部机器断电）。如果系统中有自动拉起机制（即检测到服务停止后重启该服务）将master自动重启，由于没有持久化文件，那么master重启后数据是空的，slave同步数据也变成了空的。应尽量避免“自动拉起机制”和“不做持久化”同时出现。



**所以一般可以采用以下方案：**

**主服务器不开启持久化，使得主服务器性能更好。**

**从服务器开启AOF持久化，关闭RDB持久化，并且定时对AOF文件进行备份，以及在凌晨执行bgaofrewrite命令来进行AOF文件重写，减小AOF文件大小。（当然如果对数据丢失容忍度高也可以开启RDB持久化，关闭AOF持久化）**



##### 4.异地灾备

一般性的故障（停电，关机）不会影响到磁盘，但是一些灾难性的故障（地震，洪水）会影响到磁盘，所以需要定时把单机上或从服务器上的AOF文件，RDB文件备份到其他地区的机房。



>[谈一谈你对Redis持久化的理解](https://mp.weixin.qq.com/s/nff4fd5TnM-CMWb1hQIT9Q)
>
>[Redis持久化](https://juejin.im/post/5b70dfcf518825610f1f5c16)





## Redis 锁

> [面试被问Redis锁的缺点，被打击的扎心了](https://juejin.im/post/5b70dfcf518825610f1f5c16)



* setnx

  特性 只有值不存在才能set成功

  set key value + 过期时间  + NX  （2013年之后 set 支持 了 nx 参数  官网也说明 之后setnx 会删除 因为setnx 不能设置过期时间 需要两条命令 就不是原子性了）

  ![image-20200610220632310](assets/image-20200610220632310.png)

  加锁流程  进程A set nx 加锁 因为不存在值 所以加锁成功

  进程B 进行加锁 因为有值 所以加锁失败

  解锁流程

  ​		最初版本是 过期时间到了就解锁 但是这样可能进程A还没有执行完成

  ​		这时候进程B拿到了锁 之后进程A又删除了B的锁。。。。 导致问题。

  ​		所以我们要利用value值。规定谁加锁 谁解锁

* redisson

  ​     redisson 的加锁 采用了传统的setnx +lua脚本 是因为他在脚本还做了其他的一些操作 比如实现了可重入锁

* Redlock 

     分布式锁

  ![image-20200610221501783](assets/image-20200610221501783.png)
  * **顺序向五个节点请求加锁**
  * **根据一定的超时时间来推断是不是跳过该节点**
  * **三个节点加锁成功并且花费时间小于锁的有效期**
  * **认定加锁成功**

