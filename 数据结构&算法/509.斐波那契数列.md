**斐波那契数**，通常用 `F(n)` 表示，形成的序列称为**斐波那契数列**。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

给定 `N`，计算 `F(N)`。

 

**示例 1：**

```
输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.
```

**示例 2：**

```
输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2.
```

**示例 3：**

```
输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
```

 

**提示：**

- 0 ≤ `N` ≤ 30





* 解题思路1 **递归**

  ```java
      public int fib(int N) {
          if(N==0){
              return 0;
          }
          if(N==1){
              return 1;
          }
          return fib(N-1)+fib(N-2);
      }
  ```

   数据大的时候 会跑不下去。 因为很多重复执行 如 fib(10) 会执行 fib(3)  fib(9) 也会执行fib(3)

  时间复杂度为O(2^N)（主定理，或者枚举计算，等比求和），空间复杂度是O(n)，递归调用栈的空间

* 解题思路2 **递归加记忆化**

  把每个f（n）保存起来，如果计算过就不计算了，空间换时间的思维，时间复杂度为O(N)，空间复杂度O(N)

* 解题思路3 **递推**

  ```java
    public int fib(int N){
            int len= N<=1? 2:N+1;
            int[] arr=new int[len];
            arr[0]=0;
            arr[1]=1;
              for(int i=2;i<=N;i++){
                  arr[i]=arr[i-1]+arr[i-2];
          }
          return arr[N];
      }
  ```

  时间复杂度为O(N)，空间复杂度O(1)

  ​        可以看出，每一个新的f(n)，是前两个旧的f(n-1)和f(n-2)之和，一路递归下去，最终都将递归到f(0)和f(1)上来。

  反过来想，我们不倒着f(n),f(n-1),f(n-2)这么计算，而是f(0),f(1),f(2)…f(n)这么正向计算，岂不是更快么？

* 解题思路4

  通项公式法，即是求解power(a, n)，时间复杂度O(lgN)，空间复杂度O(1)

* 解题思路5 **查表法**

   空间换时间的极致，时间复杂度O(1)，空间复杂度(嗯，很大，不知道怎么表示？)

​      

[斐波那契数列解法](https://yq.aliyun.com/articles/646447?spm=a2c4e.11153940.bloghomeflow.69.70e1291aNGkuPW)

